# Authentication Guide - Company Standard (Session + Identity Library + Roles)

## Overview
This guide shows how to add **session-based authentication with role-based authorization** using **ASP.NET Identity library** (NO manual JWT generation, NO cookies for tokens). Token is generated by Identity and stored in session.

---

## Step 1: Install Required Packages

```bash
dotnet add package Microsoft.AspNetCore.Identity.EntityFrameworkCore
```

**Important:** Make sure you install this package BEFORE creating migrations!

---

## Step 2: Configure appsettings.json (BEST PRACTICE)

**Location:** `appsettings.json`

```json
{
  "ConnectionStrings": {
    "DefaultConnection": "Server=YOUR_SERVER;Database=YOUR_DB;Trusted_Connection=True;MultipleActiveResultSets=true;TrustServerCertificate=true"
  },
  "Authentication": {
    "SessionTimeoutMinutes": 30,
    "RequireConfirmedAccount": false,
    "Password": {
      "RequireDigit": true,
      "RequireLowercase": true,
      "RequireUppercase": true,
      "RequireNonAlphanumeric": false,
      "RequiredLength": 6
    }
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*"
}
```

**Session Timeout Guidelines:**
- **30 minutes** - Industry standard
- **15-20 minutes** - High security (banking, healthcare)
- **60 minutes** - Internal tools

---

## Step 3: Add ApplicationUser.cs

**Location:** `Auth/ApplicationUser.cs` or `Models/ApplicationUser.cs`

```csharp
using Microsoft.AspNetCore.Identity;

namespace YourProject.Auth
{
    public class ApplicationUser : IdentityUser
    {
        public string FullName { get; set; } = string.Empty;
    }
}
```

**Note:** You can add more properties here (e.g., PhoneNumber, Address, etc.)

---

## Step 4: Add DTOs

### RegisterDto.cs
**Location:** `Auth/RegisterDto.cs` or `DTOs/RegisterDto.cs`

```csharp
namespace YourProject.Auth
{
    public class RegisterDto
    {
        public string FullName { get; set; } = string.Empty;
        public string Username { get; set; } = string.Empty;
        public string Email { get; set; } = string.Empty;
        public string Password { get; set; } = string.Empty;
        public string Role { get; set; } = "User";  // Default role is User
    }
}
```

### LoginDto.cs
**Location:** `Auth/LoginDto.cs` or `DTOs/LoginDto.cs`

```csharp
namespace YourProject.Auth
{
    public class LoginDto
    {
        public string Email { get; set; } = string.Empty;
        public string Password { get; set; } = string.Empty;
    }
}
```

---

## Step 5: Update DbContext

**Location:** `Data/AppDbContext.cs`

**IMPORTANT:** Change `DbContext` to `IdentityDbContext<ApplicationUser>`

```csharp
using Microsoft.AspNetCore.Identity.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore;
using YourProject.Auth;

namespace YourProject.Data
{
    public class AppDbContext : IdentityDbContext<ApplicationUser>
    {
        public AppDbContext(DbContextOptions<AppDbContext> options) : base(options)
        {
        }
        
        // Keep your existing DbSets
        public DbSet<YourProject.Models.Course> Courses { get; set; }
    }
}
```

**What This Does:**
- `IdentityDbContext` automatically creates Identity tables (AspNetUsers, AspNetRoles, AspNetUserRoles, etc.)
- Keep all your existing DbSets (Courses, Students, etc.)

---

## Step 6: Create SessionAuthenticationMiddleware

**Location:** `Middleware/SessionAuthenticationMiddleware.cs`

**IMPORTANT:** Create Middleware folder if it doesn't exist!

```csharp
using Microsoft.AspNetCore.Identity;
using YourProject.Auth;

namespace YourProject.Middleware
{
    public class SessionAuthenticationMiddleware
    {
        private readonly RequestDelegate _next;

        public SessionAuthenticationMiddleware(RequestDelegate next)
        {
            _next = next;
        }

        public async Task InvokeAsync(HttpContext context, UserManager<ApplicationUser> userManager, SignInManager<ApplicationUser> signInManager)
        {
            var token = context.Session.GetString("AuthToken");
            var userId = context.Session.GetString("UserId");

            if (!string.IsNullOrEmpty(token) && !string.IsNullOrEmpty(userId))
            {
                var user = await userManager.FindByIdAsync(userId);
                if (user != null)
                {
                    var isValid = await userManager.VerifyUserTokenAsync(user, TokenOptions.DefaultProvider, "API", token);
                    if (isValid)
                    {
                        await signInManager.SignInAsync(user, isPersistent: false);
                    }
                }
            }

            await _next(context);
        }
    }
}
```

**What This Does:**
- Runs on EVERY request
- Retrieves token from session
- Validates token using Identity library
- Signs in user automatically if token is valid
- Makes `[Authorize]` attribute work

---

## Step 7: Add AuthController

**Location:** `Auth/AuthController.cs` or `Controllers/AuthController.cs`

```csharp
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Mvc;
using YourProject.Auth;

namespace YourProject.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class AuthController : ControllerBase
    {
        private readonly UserManager<ApplicationUser> _userManager;
        private readonly SignInManager<ApplicationUser> _signInManager;

        public AuthController(
            UserManager<ApplicationUser> userManager,
            SignInManager<ApplicationUser> signInManager)
        {
            _userManager = userManager;
            _signInManager = signInManager;
        }

        [AllowAnonymous]
        [HttpPost("register")]
        public async Task<IActionResult> Register(RegisterDto dto)
        {
            var user = new ApplicationUser
            {
                UserName = dto.Email,
                Email = dto.Email,
                FullName = dto.FullName
            };

            var result = await _userManager.CreateAsync(user, dto.Password);

            if (!result.Succeeded)
                return BadRequest(result.Errors);

            // Assign role to user
            await _userManager.AddToRoleAsync(user, dto.Role);

            return Ok(new { message = "Registration successful" });
        }

        [HttpPost("login")]
        [AllowAnonymous]
        public async Task<IActionResult> Login(LoginDto dto)
        {
            var user = await _userManager.FindByEmailAsync(dto.Email);
            if (user == null)
                return Unauthorized(new { message = "Invalid credentials" });

            var result = await _signInManager.PasswordSignInAsync(
                user.UserName, 
                dto.Password, 
                isPersistent: false, 
                lockoutOnFailure: false);

            if (!result.Succeeded)
                return Unauthorized(new { message = "Invalid credentials" });

            var token = await _userManager.GenerateUserTokenAsync(user, TokenOptions.DefaultProvider, "API");
            
            HttpContext.Session.SetString("AuthToken", token);
            HttpContext.Session.SetString("UserId", user.Id);

            // Get user roles
            var roles = await _userManager.GetRolesAsync(user);

            return Ok(new { message = "Login successful", token = token, roles = roles });
        }

        [Authorize]
        [HttpPost("logout")]
        public async Task<IActionResult> Logout()
        {
            await _signInManager.SignOutAsync();
            HttpContext.Session.Clear();
            return Ok(new { message = "Logout successful" });
        }

        [Authorize]
        [HttpGet("me")]
        public async Task<IActionResult> GetCurrentUser()
        {
            var user = await _userManager.GetUserAsync(User);
            if (user == null)
                return Unauthorized();

            var roles = await _userManager.GetRolesAsync(user);

            return Ok(new
            {
                email = user.Email,
                username = user.UserName,
                fullName = user.FullName,
                roles = roles
            });
        }
    }
}
```

---

## Step 8: Configure Program.cs

**Location:** `Program.cs`

**CRITICAL:** Order matters! Follow this exactly:

```csharp
using Microsoft.AspNetCore.Identity;
using Microsoft.EntityFrameworkCore;
using YourProject.Data;
using YourProject.Auth;
using YourProject.Middleware;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddControllers();
builder.Services.AddOpenApi();

// 1. Add DbContext FIRST
builder.Services.AddDbContext<AppDbContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));

// 2. Add Identity (AFTER DbContext)
var authConfig = builder.Configuration.GetSection("Authentication");

builder.Services.AddIdentity<ApplicationUser, IdentityRole>(options =>
{
    options.Password.RequireDigit = authConfig.GetValue<bool>("Password:RequireDigit");
    options.Password.RequireLowercase = authConfig.GetValue<bool>("Password:RequireLowercase");
    options.Password.RequireUppercase = authConfig.GetValue<bool>("Password:RequireUppercase");
    options.Password.RequireNonAlphanumeric = authConfig.GetValue<bool>("Password:RequireNonAlphanumeric");
    options.Password.RequiredLength = authConfig.GetValue<int>("Password:RequiredLength");
    options.SignIn.RequireConfirmedAccount = authConfig.GetValue<bool>("RequireConfirmedAccount");
})
    .AddEntityFrameworkStores<AppDbContext>()
    .AddDefaultTokenProviders();

// 3. Add Session
builder.Services.AddDistributedMemoryCache();

builder.Services.AddSession(options =>
{
    options.IdleTimeout = TimeSpan.FromMinutes(authConfig.GetValue<int>("SessionTimeoutMinutes"));
    options.Cookie.HttpOnly = true;
    options.Cookie.IsEssential = true;
});

var app = builder.Build();

// 4. Seed Roles (IMPORTANT: Creates Admin and User roles)
using (var scope = app.Services.CreateScope())
{
    var roleManager = scope.ServiceProvider.GetRequiredService<RoleManager<IdentityRole>>();
    var roles = new[] { "Admin", "User" };  // Add more roles here if needed
    
    foreach (var role in roles)
    {
        if (!await roleManager.RoleExistsAsync(role))
        {
            await roleManager.CreateAsync(new IdentityRole(role));
        }
    }
}

if (app.Environment.IsDevelopment())
{
    app.MapOpenApi();
}

app.UseHttpsRedirection();

// 5. Middleware Pipeline (ORDER IS CRITICAL!)
app.UseSession();                                        // 1. Must be first
app.UseMiddleware<SessionAuthenticationMiddleware>();    // 2. Our custom middleware
app.UseAuthentication();                                 // 3. Identity authentication
app.UseAuthorization();                                  // 4. Identity authorization

app.MapControllers();

app.Run();
```

**Important Notes:**
- Order in middleware pipeline CANNOT be changed
- Role seeding runs once on startup
- Add more roles to the `roles` array as needed

---

## Step 9: Add [Authorize] with Roles to Controllers

**Example:** Any controller that needs protection

```csharp
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using YourProject.DTOs;

namespace YourProject.Controllers
{
    [Authorize]  // All endpoints require authentication
    [Route("api/[controller]")]
    [ApiController]
    public class CoursesController : ControllerBase
    {
        // GET endpoints - All authenticated users can access
        [HttpGet]
        public async Task<ActionResult<IEnumerable<CourseDto>>> GetCourses()
        {
            // Both Admin and User can view
        }

        [HttpGet("{code}")]
        public async Task<ActionResult<CourseDto>> GetCourse(string code)
        {
            // Both Admin and User can view
        }

        // POST/PUT/DELETE endpoints - Only Admin can access
        [HttpPost]
        [Authorize(Roles = "Admin")]
        public async Task<IActionResult> CreateCourse(CourseDto courseDto)
        {
            // Only Admin can create
        }

        [HttpPut("{code}")]
        [Authorize(Roles = "Admin")]
        public async Task<IActionResult> UpdateCourse(string code, CourseDto courseDto)
        {
            // Only Admin can update
        }

        [HttpDelete("{code}")]
        [Authorize(Roles = "Admin")]
        public async Task<IActionResult> DeleteCourse(string code)
        {
            // Only Admin can delete
        }
    }
}
```

**Role Options:**
- `[Authorize]` - Any authenticated user
- `[Authorize(Roles = "Admin")]` - Only Admin
- `[Authorize(Roles = "Admin,User")]` - Admin OR User
- `[Authorize(Roles = "Admin,Manager")]` - Admin OR Manager

---

## Step 10: Create Migration and Update Database

**IMPORTANT:** Run these commands in order:

```bash
# 1. Create migration for Identity tables
dotnet ef migrations add AddIdentityAuth

# 2. Update database (creates all Identity tables)
dotnet ef database update
```

**What Gets Created:**
- `AspNetUsers` - User accounts
- `AspNetRoles` - Roles (Admin, User, etc.)
- `AspNetUserRoles` - Links users to roles
- `AspNetUserClaims` - User claims
- `AspNetUserLogins` - External logins
- `AspNetUserTokens` - User tokens
- `AspNetRoleClaims` - Role claims

**Note:** Role seeding in Program.cs populates AspNetRoles table automatically. No separate migration needed for role data.

---

## Quick Reference: What Each File Does

| File | Purpose |
|------|---------|
| `ApplicationUser.cs` | Extends IdentityUser with custom properties |
| `RegisterDto.cs` | Data for user registration (includes Role) |
| `LoginDto.cs` | Data for user login |
| `AppDbContext.cs` | Database context (must inherit IdentityDbContext) |
| `SessionAuthenticationMiddleware.cs` | Validates session token on each request |
| `AuthController.cs` | Handles register, login, logout, get user info |
| `Program.cs` | Configures services, seeds roles, middleware pipeline |
| `appsettings.json` | Configuration (timeouts, password rules) |

---

## Testing Your Auth

### 1. Register Admin
```http
POST http://localhost:5066/api/auth/register
Content-Type: application/json

{
  "fullName": "Admin User",
  "username": "admin",
  "email": "admin@test.com",
  "password": "Admin123",
  "role": "Admin"
}
```

### 2. Register User
```http
POST http://localhost:5066/api/auth/register
Content-Type: application/json

{
  "fullName": "Regular User",
  "username": "user",
  "email": "user@test.com",
  "password": "User123",
  "role": "User"
}
```

### 3. Login as Admin
```http
POST http://localhost:5066/api/auth/login
Content-Type: application/json

{
  "email": "admin@test.com",
  "password": "Admin123"
}
```
✅ Response includes: `"roles": ["Admin"]`

### 4. Test Admin-Only Endpoint
```http
POST http://localhost:5066/api/courses
Content-Type: application/json

{
  "code": "CS101",
  "name": "Intro to CS",
  "credits": 3
}
```
✅ Success if logged in as Admin
❌ 403 Forbidden if logged in as User

### 5. Test Public Endpoint
```http
GET http://localhost:5066/api/courses
```
✅ Success for both Admin and User (if endpoint has only `[Authorize]`)

---

## Common Issues & Solutions

### Issue: "Unable to resolve service for type 'Microsoft.AspNetCore.Identity.RoleManager'"
**Solution:** Make sure `AddIdentity` comes AFTER `AddDbContext` in Program.cs

### Issue: "Session not available"
**Solution:** `UseSession()` must come BEFORE `UseAuthentication()` in middleware pipeline

### Issue: "401 Unauthorized on all endpoints"
**Solution:** 
1. Check if you registered and logged in
2. Make sure middleware is added: `app.UseMiddleware<SessionAuthenticationMiddleware>()`
3. Verify session is working

### Issue: "403 Forbidden on Admin endpoints"
**Solution:**
1. Check if user was assigned Admin role during registration
2. Verify roles are returned in login response
3. Check role seeding ran successfully (check AspNetRoles table)

### Issue: Migration conflicts with existing tables
**Solution:** Backup database, then `dotnet ef database drop` and `dotnet ef database update`

---

## Role-Based Authorization Summary

| Action | Admin | User | Anonymous |
|--------|-------|------|-----------|
| Register | ✅ | ✅ | ✅ |
| Login | ✅ | ✅ | ✅ |
| View courses | ✅ | ✅ | ❌ |
| Create course | ✅ | ❌ | ❌ |
| Update course | ✅ | ❌ | ❌ |
| Delete course | ✅ | ❌ | ❌ |

---

## Summary Checklist

- [ ] Installed `Microsoft.AspNetCore.Identity.EntityFrameworkCore` package
- [ ] Created `ApplicationUser` inheriting `IdentityUser`
- [ ] Created `RegisterDto` with Role property and `LoginDto`
- [ ] Changed DbContext to inherit `IdentityDbContext<ApplicationUser>`
- [ ] Created `SessionAuthenticationMiddleware` in Middleware folder
- [ ] Created `AuthController` with register/login/logout/me endpoints
- [ ] Configured `Program.cs` with Identity, Session, and role seeding
- [ ] Added middleware in correct order
- [ ] Added `[Authorize]` and `[Authorize(Roles = "...")]` to controllers
- [ ] Configured `appsettings.json` with Authentication settings
- [ ] Created migration: `dotnet ef migrations add AddIdentityAuth`
- [ ] Updated database: `dotnet ef database update`
- [ ] Tested: Register Admin → Login → Test Admin endpoint
- [ ] Tested: Register User → Login → Test User endpoint (should get 403 on Admin-only endpoints)

---

## Final Notes

**This is the company standard way:**
1. Identity library generates token (not manual JWT)
2. Token stored in session (server-side, not client-side)
3. Configuration in appsettings.json (not hardcoded)
4. Roles seeded on startup (automatic)
5. Role-based authorization with `[Authorize(Roles = "...")]`
6. Session expires after idle timeout (30 min default, sliding expiration)
7. Middleware validates token automatically (no manual token handling)

**Use this guide for every new project that needs authentication with roles!**