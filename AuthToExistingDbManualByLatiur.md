# Authentication Guide - Company Standard (Session + Identity Library)

## Overview
This guide shows how to add **session-based authentication** using **ASP.NET Identity library** (NO manual JWT generation, NO cookies for tokens). Token is generated by Identity and stored in session.

---

## Step 1: Install Required Packages

```bash
dotnet add package Microsoft.AspNetCore.Identity.EntityFrameworkCore
```

---

## Step 2: Configure appsettings.json (BEST PRACTICE)

**Location:** `appsettings.json`

**IMPORTANT:** Store configuration in appsettings.json, NOT hardcoded in Program.cs. This is industry best practice.

```json
{
  "ConnectionStrings": {
    "DefaultConnection": "Server=YOUR_SERVER;Database=YOUR_DB;Trusted_Connection=True;MultipleActiveResultSets=true;TrustServerCertificate=true"
  },
  "Authentication": {
    "SessionTimeoutMinutes": 30,
    "RequireConfirmedAccount": false,
    "Password": {
      "RequireDigit": true,
      "RequireLowercase": true,
      "RequireUppercase": true,
      "RequireNonAlphanumeric": false,
      "RequiredLength": 6
    }
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*"
}
```

**Why appsettings.json?**
- ✅ Change settings without recompiling
- ✅ Different settings per environment (Dev, Staging, Production)
- ✅ Easier for DevOps to manage
- ✅ Industry standard practice

**Session Timeout Guidelines:**
- **30 minutes** - Industry standard (most companies)
- **15-20 minutes** - High security (banking, healthcare)
- **60 minutes** - Internal tools, low security

**Note:** Session uses **sliding expiration** by default - active users stay logged in, only idle users are logged out after timeout.

---

## Step 3: Add ApplicationUser.cs

**Location:** `Auth/ApplicationUser.cs` or `Models/ApplicationUser.cs`

```csharp
using Microsoft.AspNetCore.Identity;

namespace YourProject.Auth
{
    public class ApplicationUser : IdentityUser
    {
        public string FullName { get; set; } = string.Empty;
    }
}
```

---

## Step 4: Add DTOs

### RegisterDto.cs
**Location:** `Auth/RegisterDto.cs` or `DTOs/RegisterDto.cs`

```csharp
namespace YourProject.Auth
{
    public class RegisterDto
    {
        public string FullName { get; set; } = string.Empty;
        public string Username { get; set; } = string.Empty;
        public string Email { get; set; } = string.Empty;
        public string Password { get; set; } = string.Empty;
    }
}
```

### LoginDto.cs
**Location:** `Auth/LoginDto.cs` or `DTOs/LoginDto.cs`

```csharp
namespace YourProject.Auth
{
    public class LoginDto
    {
        public string Email { get; set; } = string.Empty;
        public string Password { get; set; } = string.Empty;
    }
}
```

---

## Step 5: Update DbContext

**Location:** `Data/AppDbContext.cs`

Replace `DbContext` with `IdentityDbContext<ApplicationUser>`:

```csharp
using Microsoft.AspNetCore.Identity.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore;
using YourProject.Auth;

namespace YourProject.Data
{
    public class AppDbContext : IdentityDbContext<ApplicationUser>
    {
        public AppDbContext(DbContextOptions<AppDbContext> options) : base(options)
        {
        }
        
        // Keep your existing DbSets
        public DbSet<YourProject.Models.Course> Courses { get; set; }
    }
}
```

---

## Step 6: Create SessionAuthenticationMiddleware

**Location:** `Middleware/SessionAuthenticationMiddleware.cs`

```csharp
using Microsoft.AspNetCore.Identity;
using YourProject.Auth;

namespace YourProject.Middleware
{
    public class SessionAuthenticationMiddleware
    {
        private readonly RequestDelegate _next;

        public SessionAuthenticationMiddleware(RequestDelegate next)
        {
            _next = next;
        }

        public async Task InvokeAsync(HttpContext context, UserManager<ApplicationUser> userManager, SignInManager<ApplicationUser> signInManager)
        {
            var token = context.Session.GetString("AuthToken");
            var userId = context.Session.GetString("UserId");

            if (!string.IsNullOrEmpty(token) && !string.IsNullOrEmpty(userId))
            {
                var user = await userManager.FindByIdAsync(userId);
                if (user != null)
                {
                    var isValid = await userManager.VerifyUserTokenAsync(user, TokenOptions.DefaultProvider, "API", token);
                    if (isValid)
                    {
                        await signInManager.SignInAsync(user, isPersistent: false);
                    }
                }
            }

            await _next(context);
        }
    }
}
```

---

## Step 7: Add AuthController

**Location:** `Auth/AuthController.cs` or `Controllers/AuthController.cs`

```csharp
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Identity;
using Microsoft.AspNetCore.Mvc;
using YourProject.Auth;

namespace YourProject.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    public class AuthController : ControllerBase
    {
        private readonly UserManager<ApplicationUser> _userManager;
        private readonly SignInManager<ApplicationUser> _signInManager;

        public AuthController(
            UserManager<ApplicationUser> userManager,
            SignInManager<ApplicationUser> signInManager)
        {
            _userManager = userManager;
            _signInManager = signInManager;
        }

        [AllowAnonymous]
        [HttpPost("register")]
        public async Task<IActionResult> Register(RegisterDto dto)
        {
            var user = new ApplicationUser
            {
                UserName = dto.Email,
                Email = dto.Email,
                FullName = dto.FullName
            };

            var result = await _userManager.CreateAsync(user, dto.Password);

            if (!result.Succeeded)
                return BadRequest(result.Errors);

            return Ok(new { message = "Registration successful" });
        }

        [HttpPost("login")]
        [AllowAnonymous]
        public async Task<IActionResult> Login(LoginDto dto)
        {
            var user = await _userManager.FindByEmailAsync(dto.Email);
            if (user == null)
                return Unauthorized(new { message = "Invalid credentials" });

            var result = await _signInManager.PasswordSignInAsync(
                user.UserName, 
                dto.Password, 
                isPersistent: false, 
                lockoutOnFailure: false);

            if (!result.Succeeded)
                return Unauthorized(new { message = "Invalid credentials" });

            // Generate token using Identity library
            var token = await _userManager.GenerateUserTokenAsync(user, TokenOptions.DefaultProvider, "API");
            
            // Store in session
            HttpContext.Session.SetString("AuthToken", token);
            HttpContext.Session.SetString("UserId", user.Id);

            return Ok(new { message = "Login successful", token = token });
        }

        [Authorize]
        [HttpPost("logout")]
        public async Task<IActionResult> Logout()
        {
            await _signInManager.SignOutAsync();
            HttpContext.Session.Clear();
            return Ok(new { message = "Logout successful" });
        }

        [Authorize]
        [HttpGet("me")]
        public async Task<IActionResult> GetCurrentUser()
        {
            var user = await _userManager.GetUserAsync(User);
            if (user == null)
                return Unauthorized();

            return Ok(new
            {
                email = user.Email,
                username = user.UserName,
                fullName = user.FullName
            });
        }
    }
}
```

---

## Step 8: Configure Program.cs (Read from appsettings.json)

**Location:** `Program.cs`

```csharp
using Microsoft.AspNetCore.Identity;
using Microsoft.EntityFrameworkCore;
using YourProject.Data;
using YourProject.Auth;
using YourProject.Middleware;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddControllers();
builder.Services.AddOpenApi();

builder.Services.AddDbContext<AppDbContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));

// Read from appsettings.json (BEST PRACTICE)
var authConfig = builder.Configuration.GetSection("Authentication");

builder.Services.AddIdentity<ApplicationUser, IdentityRole>(options =>
{
    options.Password.RequireDigit = authConfig.GetValue<bool>("Password:RequireDigit");
    options.Password.RequireLowercase = authConfig.GetValue<bool>("Password:RequireLowercase");
    options.Password.RequireUppercase = authConfig.GetValue<bool>("Password:RequireUppercase");
    options.Password.RequireNonAlphanumeric = authConfig.GetValue<bool>("Password:RequireNonAlphanumeric");
    options.Password.RequiredLength = authConfig.GetValue<int>("Password:RequiredLength");
    options.SignIn.RequireConfirmedAccount = authConfig.GetValue<bool>("RequireConfirmedAccount");
})
    .AddEntityFrameworkStores<AppDbContext>()
    .AddDefaultTokenProviders();

builder.Services.AddDistributedMemoryCache();

builder.Services.AddSession(options =>
{
    options.IdleTimeout = TimeSpan.FromMinutes(authConfig.GetValue<int>("SessionTimeoutMinutes"));
    options.Cookie.HttpOnly = true;
    options.Cookie.IsEssential = true;
});

var app = builder.Build();

if (app.Environment.IsDevelopment())
{
    app.MapOpenApi();
}

app.UseHttpsRedirection();

app.UseSession();

app.UseMiddleware<SessionAuthenticationMiddleware>();

app.UseAuthentication();

app.UseAuthorization();

app.MapControllers();

app.Run();
```

---

## Step 9: Add [Authorize] to Controllers

**Example:** `Controllers/CoursesController.cs`

```csharp
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;

[Authorize]  // ← Add this to protect all endpoints in this controller
[Route("api/[controller]")]
[ApiController]
public class CoursesController : ControllerBase
{
    // All endpoints now require authentication
}
```

Or protect specific endpoints:

```csharp
[HttpGet]
[Authorize]  // ← Only this endpoint requires authentication
public async Task<ActionResult<IEnumerable<CourseDto>>> GetCourses()
{
    // ...
}
```

---

## Step 10: Create Migration and Update Database

```bash
dotnet ef migrations add AddIdentityTables
dotnet ef database update
```

---

## Testing the Authentication

### 1. Register a User
```http
POST http://localhost:5066/api/auth/register
Content-Type: application/json

{
  "fullName": "Test User",
  "username": "testuser",
  "email": "test@test.com",
  "password": "Test123"
}
```

### 2. Login (Token stored in session automatically)
```http
POST http://localhost:5066/api/auth/login
Content-Type: application/json

{
  "email": "test@test.com",
  "password": "Test123"
}
```

### 3. Access Protected Endpoints (No manual token needed!)
```http
GET http://localhost:5066/api/courses
```

**Session cookie is sent automatically by Postman/Browser!**

### 4. Logout
```http
POST http://localhost:5066/api/auth/logout
```

---

## Key Differences from Manual JWT Approach

| Feature | Manual JWT (Old) | Session + Identity (Company Standard) |
|---------|------------------|---------------------------------------|
| Token Generation | Manual `GenerateToken()` method | Identity's `GenerateUserTokenAsync()` |
| Token Storage | Client-side (localStorage) | Server-side session |
| Token Validation | JWT middleware | Custom middleware + Identity's `VerifyUserTokenAsync()` |
| Token Handling | Manual copy-paste in Authorization header | Automatic via session cookie |
| Cookies | Not used | Session cookie only (contains session ID, not token) |
| Expiration | JWT expiration | Session expiration (60 minutes) |

---

## How It Works

1. **Login:**
   - User sends email + password
   - `SignInManager.PasswordSignInAsync()` validates credentials
   - **Identity generates token:** `_userManager.GenerateUserTokenAsync()`
   - Token stored in session: `HttpContext.Session.SetString("AuthToken", token)`
   - Session cookie (with session ID) sent to client

2. **Subsequent Requests:**
   - Client sends session cookie automatically
   - **Middleware** retrieves token from session using session ID
   - **Identity validates token:** `_userManager.VerifyUserTokenAsync()`
   - If valid, user is signed in: `_signInManager.SignInAsync()`
   - `[Authorize]` checks authentication → grants access

3. **Logout:**
   - Clears session: `HttpContext.Session.Clear()`
   - Signs out user: `_signInManager.SignOutAsync()`

---

## Important Notes

✅ **Use Identity library** - Don't create manual token generation  
✅ **Token in Session** - NOT in cookies, NOT client-side  
✅ **Automatic handling** - No manual copy-paste of tokens  
✅ **Expire time** - Set in session configuration (60 minutes default)  
✅ **Authorize attribute** - Protects endpoints  
✅ **Middleware required** - Validates session token on each request  

---

## Common Issues & Solutions

### Issue: "Session not available"
**Solution:** Make sure `app.UseSession()` comes BEFORE `app.UseAuthentication()` in Program.cs

### Issue: "Token validation fails"
**Solution:** Make sure middleware is registered: `app.UseMiddleware<SessionAuthenticationMiddleware>()`

### Issue: "401 Unauthorized on protected endpoints"
**Solution:** Login first to create session, then access protected endpoints

### Issue: "Migration conflicts with existing tables"
**Solution:** Backup database first, or use `dotnet ef database drop` to start fresh (loses all data!)

---

## Quick Checklist

- [ ] Installed `Microsoft.AspNetCore.Identity.EntityFrameworkCore` package
- [ ] Created `ApplicationUser` class inheriting `IdentityUser`
- [ ] Created `RegisterDto` and `LoginDto`
- [ ] Updated `AppDbContext` to inherit `IdentityDbContext<ApplicationUser>`
- [ ] Created `SessionAuthenticationMiddleware`
- [ ] Created `AuthController` with register/login/logout endpoints
- [ ] Configured Identity and Session in `Program.cs`
- [ ] Added middleware to request pipeline
- [ ] Added `[Authorize]` to controllers/endpoints
- [ ] Created migration and updated database
- [ ] Tested: Register → Login → Access protected endpoint

---

## Summary

This is the **company standard** way:
1. Identity library generates token
2. Token stored in session (server-side)
3. Configuration in appsettings.json (BEST PRACTICE)
4. Session expires after idle timeout (30 min default)
5. Sliding expiration - active users stay logged in

**Use this guide every time you need to add authentication to a new project!**